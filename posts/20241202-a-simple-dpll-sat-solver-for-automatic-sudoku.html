<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>A simple DPLL SAT solver for automatic Sudoku</title>
<link rel="stylesheet" type="text/css" href="../normalize.css" />
<link rel="stylesheet" type="text/css" media="all" href="../styles.css" />
<link rel="stylesheet" type="text/css" media="all" href="../pygments-styles.css" />
<link rel="stylesheet" type="text/css" media="all" href="post-styles.css" />
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>
  <header><nav><a href="../index.html">Home</a><a href="../posts.html">Posts</a></nav></header>
  <h1>A simple DPLL SAT solver for automatic Sudoku</h1><p class="post-date">Monday December 2, 2024</p><p>As part of my work at <a href="https://www.recurse.com/" target="_blank" rel="noopener noreferrer">Recurse Center</a> recently, I wrote an extremely naive DPLL SAT solver in <a href="https://racket-lang.org/" target="_blank" rel="noopener noreferrer">Racket</a> and used it to encode an automatic Sudoku solver. Using that code as a guide, here‚Äôs an attempt at some longer-form exposition on the very basics of <strong>propositional logic</strong> and <strong>automated logical reasoning</strong>.</p><aside>By the way: Racket is a cool language, and you‚Äîyes, you!‚Äîshould give it a try. It‚Äôs a direct descendant of Scheme‚Äîin some ways, it is <em>just</em> Scheme with some extensions‚Äîand it has lots of parentheses. Don‚Äôt be scared! You might like it! I think it is quite well designed and has good beginner support, along with a host of more advanced/interesting features.</aside><h2>What is a SAT solver?</h2><p>A SAT solver, or a <strong>satisfiability solver</strong>, is a program that automatically solves for the <em>satisfiability</em> of a <em>formula</em> in <em>propositional logic</em>. Let‚Äôs go over the definitions of these terms, starting from the last one and moving backwards.</p><p><em>Propositional logic</em> is a logic that consists only of logical statements built up from <em>boolean variables</em> and your standard logical connectives: conjunction (and), disjunction (or), implication (implies), biconditional (if and only if), and negation (not). A boolean variable can either be <strong>true</strong> or <strong>false</strong>. There are certainly more technical definitions, but this should serve our purposes here.</p><p>A <em>formula</em> is simply some logical statement.</p><p>The <em>satisfiability</em> of a formula is the problem of determining whether there is an assignment to all the free variables in a formula (also called an <em>interpretation</em>) such that the formula is <strong>true</strong>. If there is, the formula is <strong>satisfiable</strong> (or SAT, in some lingo). If there isn‚Äôt, the formula is <strong>unsatisfiable</strong> (or UNSAT). Such an assignment‚Äîone that makes the formula evaluate to <strong>true</strong>‚Äîis called a <em>model</em>.</p><p>Something very nice about propositional logic is that the satisfiability of formulae in it is <em>decidable</em>. <strong>Decidability</strong> essentially means: <strong>there exists some algorithm (i.e. a mechanical procedure) that always terminates and always gives back a correct answer.</strong></p><p>This is pretty exciting‚Äîit means that we can solve the satisfiability problem for propositional logic <em>automatically</em>, without needing to resort to human ingenuity. This is also what makes SAT solvers possible, from a theoretical perspective.</p><aside>SAT solvers form the basis of some more powerful, practical tools called SMT solvers (where SMT stands for satisfiability modulo theories). SMT solvers extend SAT solvers with <em>decidable theories</em> of first-order logic‚Äîat a high level, this basically means that they can automatically solve logical formulae that include more advanced and more realistic things, i.e. integers, rational numbers, arrays, strings, and so on. We won‚Äôt go into more detail about SMT solvers here.</aside><p>SAT solvers, in this sense, just implement some algorithm that decides the satisfiability of a propositional logic formula. The algorithm that most (if not all) modern SAT solvers are built on is named <strong>DPLL</strong>, after its cited inventors: Martin Davis, Hilary Putnam, George Logemann, and Donald Loveland. DPLL operates only on propositional logic formulae in <em>conjunctive normal form</em> (CNF).</p><p>Conjunctive normal form is a conjunction of <em>clauses</em>, each of which are a series of disjunctions. To make it a bit more concrete, here‚Äôs the structure of a formula in CNF:<br/>$$(A_1 \lor A_2 \lor \ldots) \land (B_1 \lor B_2 \lor \ldots) \land (C_1 \lor C_2 \lor \ldots) \land \ldots$$</p><p>DPLL is a fairly simple algorithm at heart‚Äîwe‚Äôll try and give a taste of it.</p><aside>There are a large number of extensions and optimizations to classic, naive DPLL. We won‚Äôt really cover them here. The most important one though, at least from a contemporary standpoint, is something called <strong>conflict-driven clause-learning (CDCL)</strong>. The gist of CDCL is that, whenever we hit a <em>conflict</em> in DPLL (i.e. when we make an assignment that results in the formula being <strong>false</strong>), we add a clause to the formula that <em>encodes the ‚Äúwhy‚Äù behind the conflict</em>, so that we don‚Äôt go down that path again. The specifics are too much for now.</aside><h2>DPLL at its simplest</h2><p>DPLL is a <em>backtracking search</em> algorithm‚Äîat its core, it guesses an assignment, propagates that assignment throughout the formula, guesses another assignment, and so on, searching through possible options. If it ever hits a conflict, it <em>backtracks</em> to a previous stage before the conflict. Then it will make another best effort guess and continue as before.</p><p>That said, DPLL has a bit of cleverness up its sleeve in the form of something called <strong>boolean constraint propagation (BCP)</strong>, which is based on <strong>unit resolution</strong>. The idea behind unit resolution is simple: if there is a <em>unit clause</em>‚Äîa clause that <em>only has one literal in it</em>‚Äîthen we <em>must</em> assign the Boolean value that makes the literal in the unit clause true. This is called an <strong>implied assignment</strong>.</p><p><strong>BCP</strong> is just a fancy/concise name for the act of applying <strong>unit resolution</strong> repeatedly, as much as possible.</p><aside>Here is an example of applying BCP to the formula: $(\lnot A) \land (A \lor \lnot B)$. The first clause is unit, implying the assignment ‚Äú$A$ is <strong>false</strong>.‚Äù This produces $(\lnot B)$, which is also a unit clause implying the assigmnent ‚Äú$B$ is <strong>false</strong>.‚Äù Thus, we have a satisfying assignment, where $A$ and $B$ are both <strong>false</strong>.</aside><p>Besides BCP, DPLL is basically just a brute-force search algorithm. Whenever we can‚Äôt apply BCP, we take some free variable in the formula, assign it an arbitrary Boolean value, and then see what happens (backtracking when we hit a conflict). Here is the algorithm, at a high level, in ML-like pseudocode:</p><div class="highlight"><div class="source"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="nc">DPLL</span> <span class="nc">F</span> <span class="o">=</span>
  <span class="k">let</span> <span class="nc">F&#39;</span> <span class="o">=</span> <span class="nc">BCP</span> <span class="nc">F</span> <span class="k">in</span>
  <span class="k">if</span> <span class="nc">F&#39;</span> <span class="o">=</span> <span class="nc">SAT</span> <span class="k">then</span> <span class="bp">true</span>
  <span class="k">else</span> <span class="k">if</span> <span class="nc">F&#39;</span> <span class="o">=</span> <span class="nc">UNSAT</span> <span class="k">then</span> <span class="bp">false</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="nc">P</span> <span class="o">=</span> <span class="nc">CHOOSE_FREE_VAR</span> <span class="nc">F&#39;</span> <span class="k">in</span>
    <span class="o">(</span><span class="nc">DPLL</span> <span class="o">(</span><span class="nc">F&#39;</span> <span class="n">where</span> <span class="nc">P</span> <span class="n">is</span> <span class="bp">true</span><span class="o">))</span> <span class="o">||</span> <span class="o">(</span><span class="nc">DPLL</span> <span class="o">(</span><span class="nc">F&#39;</span> <span class="n">where</span> <span class="nc">P</span> <span class="n">is</span> <span class="bp">false</span><span class="o">))</span>
</pre></div></div><h2>Some implementation details</h2><p>There are a couple quick rules we can use to propagate an assignment (regardless of whether it‚Äôs <em>implied</em>‚Äîmeaning that it results from unit resolution‚Äîor <em>decided</em>‚Äîmeaning that it is a best-effort guess). They are:</p><ol><li>If an assignment makes a literal in a clause <strong>true</strong>, we can remove the entire clause from the formula without changing its satisfiability.</li><li>If an assignment makes a literal in a clause <strong>false</strong>, we can remove that literal from the clause without changing its satisfiability.</li></ol><p>There are two corresponding rules for determining if the end result of DPLL, implemented using the propagation rules above, is UNSAT or SAT. They are:</p><ol><li>If we reach a point where there are <em>no clauses left</em>, the formula is SAT.</li><li>If we reach a point where there is an <em>entirely empty clause</em> in the formula, the formula is UNSAT.</li></ol><p>Take a bit to think about why all these rules are true and how the first two relate to the second two. Also, here is some Racket code that implements the UNSAT/SAT determination described.</p><div class="highlight"><div class="source"><pre><span></span><span class="c1">;; If all clauses have been removed, we have SAT</span><br/><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sat?</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span><br/><span class="c1">;; If any clause is empty, we have UNSAT</span><br/><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">unsat?</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="nb">ormap</span><span class="w"> </span><span class="p">(</span><span class="k">Œª</span><span class="w"> </span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span><span class="w"> </span><span class="n">f</span><span class="p">))</span>
</pre></div></div><p>Now, here‚Äôs a bit of Racket code that implements both the propagation logic and the overall BCP step of DPLL. Note that there are some differences from the pseudocode given earlier, primarily because we want to <strong>save our assignments</strong>. It‚Äôs nice to get a constructive satisfying assignment when a formula is satisfiable‚Äîfor example, it will let us get an actual solution to a Sudoku puzzle (as opposed to simply saying whether the puzzle can be solved).</p><div class="highlight"><div class="source"><pre><p><span></span><span class="c1">;; NOTE: sign must be a boolean (#t or #f). #f means negation. var should be</span><br/><span class="c1">;; represented by an arbitrary positive integer.</span><br/><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">lit</span><span class="w"> </span><span class="p">(</span><span class="n">sign</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="kd">#:transparent</span><span class="p">)</span></p><p><span class="c1">;; propagate-assignment takes an assignment to a variable and</span><br/><span class="c1">;; propagates it throughout the formula using some simple rules.</span><br/><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">propagate-assignment</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">b-assign</span><span class="w"> </span><span class="n">cnf</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">propagate-iter</span><span class="w"> </span><span class="n">in-cnf</span><span class="w"> </span><span class="n">out-cnf</span><span class="p">)</span><br/><span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">in-cnf</span><span class="p">)</span><br/><span class="w">        </span><span class="n">out-cnf</span><br/><span class="w">        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">cl</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">in-cnf</span><span class="p">)]</span><br/><span class="w">              </span><span class="p">[</span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">in-cnf</span><span class="p">)])</span><br/><span class="w">          </span><span class="p">(</span><span class="n">propagate-iter</span><br/><span class="w">           </span><span class="n">xs</span><br/><span class="w">           </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">findf</span><span class="w"> </span><span class="p">(</span><span class="k">Œª</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">lit</span><span class="w"> </span><span class="n">b-assign</span><span class="w"> </span><span class="n">var</span><span class="p">)))</span><span class="w"> </span><span class="n">cl</span><span class="p">)</span><br/><span class="w">               </span><span class="c1">;; If the assignment results in a literal that evaluates</span><br/><span class="w">               </span><span class="c1">;; to TRUE, completely remove the clause</span><br/><span class="w">               </span><span class="n">out-cnf</span><br/><span class="w">               </span><span class="c1">;; Otherwise, remove matching lits from the clause</span><br/><span class="w">               </span><span class="c1">;; (but not the whole clause!)</span><br/><span class="w">               </span><span class="p">(</span><span class="nb">cons</span><br/><span class="w">                </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">Œª</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="n">lit-var</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">var</span><span class="p">)))</span><span class="w"> </span><span class="n">cl</span><span class="p">)</span><br/><span class="w">                </span><span class="n">out-cnf</span><span class="p">))))))</span><br/><span class="w">  </span><span class="p">(</span><span class="n">propagate-iter</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span></p><p><span class="c1">;; bcp recursively finds a unit clause and then propagates the implication.</span><br/><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">bcp-results</span><span class="w"> </span><span class="p">(</span><span class="n">cnf</span><span class="w"> </span><span class="n">assignments</span><span class="p">))</span><br/><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">bcp</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="n">assignments</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">search-for-unit</span><span class="p">)</span><br/><span class="w">    </span><span class="p">(</span><span class="nb">findf</span><span class="w"> </span><span class="p">(</span><span class="k">Œª</span><span class="w"> </span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="n">clause</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">cnf</span><span class="p">))</span><br/><span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">found-unit</span><span class="w"> </span><span class="p">(</span><span class="n">search-for-unit</span><span class="p">)])</span><br/><span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="n">found-unit</span><span class="p">)</span><br/><span class="w">        </span><span class="p">(</span><span class="n">bcp-results</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="n">assignments</span><span class="p">)</span><br/><span class="w">        </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">([</span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">found-unit</span><span class="p">)]</span><br/><span class="w">               </span><span class="p">[</span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">lit-var</span><span class="w"> </span><span class="n">l</span><span class="p">)])</span><br/><span class="w">          </span><span class="c1">;; NOTE: The implied variable assignment will always be (lit-sign l)</span><br/><span class="w">          </span><span class="p">(</span><span class="n">bcp</span><br/><span class="w">           </span><span class="p">(</span><span class="n">propagate-assignment</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">lit-sign</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">cnf</span><span class="p">)</span><br/><span class="w">           </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">(</span><span class="n">lit-sign</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w"> </span><span class="n">assignments</span><span class="p">))))))</span>
</p></pre></div></div><p>The last piece we need is a way to choose a free variable to <em>decide</em> an assignment for, when we finish using BCP. This corresponds to the <code>CHOOSE_FREE_VAR</code> function in our ML-like pseudocode earlier. The simplest way to do this is just to choose the first free variable in the first clause of our formula. There are more elaborate and efficient ways to make this choice‚Äîin fact, making smart choices here can lead to big speedups in SAT solving!‚Äîbut this simple choice will do for now.</p><div class="highlight"><div class="source"><pre><span></span><span class="c1">;; choose-unassigned-var naively takes the first variable in the CNF.</span><br/><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">choose-unassigned</span><span class="w"> </span><span class="n">cnf</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="n">lit-var</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">cnf</span><span class="p">))))</span>
</pre></div></div><p>Now, we can put it all together! Here‚Äôs the Racket code for the DPLL function, using all the functions we‚Äôve built up so far:</p><div class="highlight"><div class="source"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dpll</span><span class="w"> </span><span class="n">cnf</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dpll-assignments</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="n">assignments</span><span class="p">)</span><br/><span class="w">    </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">([</span><span class="n">res</span><span class="w"> </span><span class="p">(</span><span class="n">bcp</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())]</span><br/><span class="w">           </span><span class="p">[</span><span class="n">res-cnf</span><span class="w"> </span><span class="p">(</span><span class="n">bcp-results-cnf</span><span class="w"> </span><span class="n">res</span><span class="p">)]</span><br/><span class="w">           </span><span class="p">[</span><span class="n">res-ass</span><span class="w"> </span><span class="p">(</span><span class="n">bcp-results-assignments</span><span class="w"> </span><span class="n">res</span><span class="p">)]</span><br/><span class="w">           </span><span class="p">[</span><span class="n">new-ass</span><span class="w"> </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="n">res-ass</span><span class="w"> </span><span class="n">assignments</span><span class="p">)])</span><br/><span class="w">      </span><span class="p">(</span><span class="k">cond</span><br/><span class="w">        </span><span class="p">[(</span><span class="n">sat?</span><span class="w"> </span><span class="n">res-cnf</span><span class="p">)</span><span class="w"> </span><span class="n">new-ass</span><span class="p">]</span><br/><span class="w">        </span><span class="p">[(</span><span class="n">unsat?</span><span class="w"> </span><span class="n">res-cnf</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">]</span><br/><span class="w">        </span><span class="p">[</span><span class="k">else</span><br/><span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="n">choose-unassigned</span><span class="w"> </span><span class="n">res-cnf</span><span class="p">)])</span><br/><span class="w">           </span><span class="p">(</span><span class="k">or</span><br/><span class="w">            </span><span class="p">(</span><span class="n">dpll-assignments</span><span class="w"> </span><span class="p">(</span><span class="n">propagate-assignment</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="n">res-cnf</span><span class="p">)</span><br/><span class="w">                              </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="no">#t</span><span class="p">)</span><span class="w"> </span><span class="n">new-ass</span><span class="p">))</span><br/><span class="w">            </span><span class="p">(</span><span class="n">dpll-assignments</span><span class="w"> </span><span class="p">(</span><span class="n">propagate-assignment</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="n">res-cnf</span><span class="p">)</span><br/><span class="w">                              </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span><span class="w"> </span><span class="n">new-ass</span><span class="p">))))])))</span><br/><span class="w">  </span><span class="p">(</span><span class="n">dpll-assignments</span><span class="w"> </span><span class="n">cnf</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
</pre></div></div><h2>Encoding the rules of Sudoku</h2><p>Something relatively simple and cool we can do with a SAT solver is use it automatically solve Sudoku puzzles. Is this particularly useful in practice? Not necessarily. But it‚Äôs definitely fun to see the solver in action! At least I think so.</p><aside>There are <em>a lot</em> of practically useful applications of SMT solving (and SAT solving, by implication), particularly in the domains of programming languages and formal methods. <strong>It turns out that many problems in computational systems can be represented as satisfiability problems over some carefully crafted logical formulae!</strong> SMT solvers can be leveraged in program verification tools (a la Dafny, Verus, etc.), program synthesis (i.e. VeriEQL, various applications of Rosette, etc.), distributed systems verification (a la lineage-driven fault injection), refinement-type checking (a la dsolve and Liquid Haskell), and so on. They are a powerful way to get <em>automatic</em> and <em>verifiably correct</em> answers to complex problems.</aside><p>We won‚Äôt go over the details of the encoding here (an exercise for the reader!), but here are the high-level ideas and some starter code. We need to encode the following rules of Sudoku as propositional logic formulae in CNF form:</p><ul><li>We must respect the initial configuration (the clues) of the board.</li><li>Each cell must have <em>at least one</em> number.</li><li>In each row/column/square (in a 9 by 9 board, squares are the smaller 3 by 3 sub-boards), a number can occur <em>at most once</em>.</li></ul><p>As a hint for the <em>at most once</em> constraint, think about <em>pairwise comparisons</em>. For example, let $A_i$ be a Boolean variable representing the statement ‚ÄúThe number $1$ is placed in (row $0$, column $i$) of the Sudoku board.‚Äù To encode the fact that the number $1$ can appear <em>at most once</em> in row $0$, we can represent it as a conjunction of disjunctions of all possible pairs in the row:<br/>$$(\lnot A_1 \lor \lnot A_2) \land (\lnot A_1 \lor \lnot A_3) \land (\lnot A_1 \lor \lnot A_4) \ldots$$</p><p>Another potential difficulty is figuring out how to map logical statements like ‚Äúthe number $1$ is placed in (row $0$, column $5$) of the Sudoku board‚Äù to variables in our SAT solver, given that our variables are currently just represented by positive integers. There are various approaches to this (one might be to just have some hashmap that we maintain), but here‚Äôs a clever-ish way to use arithmetic to get an encoding between specific guesses (logical statements) and variables (in our case, positive integers).</p><div class="highlight"><div class="source"><pre><p><span></span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">coord</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="kd">#:transparent</span><span class="p">)</span><br/><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="kd">#:transparent</span><span class="p">)</span></p><p><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">encode-guess-as-var</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">([</span><span class="n">row</span><span class="w"> </span><span class="p">(</span><span class="n">guess-row</span><span class="w"> </span><span class="n">guess</span><span class="p">)]</span><br/><span class="w">        </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="n">guess-col</span><span class="w"> </span><span class="n">guess</span><span class="p">)]</span><br/><span class="w">        </span><span class="p">[</span><span class="n">num</span><span class="w"> </span><span class="p">(</span><span class="n">guess-num</span><span class="w"> </span><span class="n">guess</span><span class="p">)])</span><br/><span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="n">col</span><span class="p">)))))</span></p><p><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">decode-guess-as-var</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">([</span><span class="n">num</span><span class="w"> </span><span class="p">(</span><span class="nb">modulo</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">n</span><span class="p">)]</span><br/><span class="w">         </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="nb">modulo</span><span class="w"> </span><span class="p">(</span><span class="nb">quotient</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)]</span><br/><span class="w">         </span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="p">(</span><span class="nb">modulo</span><span class="w"> </span><span class="p">(</span><span class="nb">quotient</span><span class="w"> </span><span class="p">(</span><span class="nb">quotient</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)])</span><br/><span class="w">    </span><span class="p">(</span><span class="n">guess</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">num</span><span class="p">)))</span></p><p><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">get-var-from-coord-num</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><br/><span class="w">  </span><span class="p">(</span><span class="n">encode-guess-as-var</span><span class="w"> </span><span class="p">(</span><span class="n">guess</span><span class="w"> </span><span class="p">(</span><span class="n">coord-row</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">coord-col</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>
</p></pre></div></div><h2>Further references</h2><p>For further reading, there are a couple books that often get recommended (at least at the time of writing). Go crazy! Read them! They are:</p><ul><li>The Calculus of Computation (Bradley and Manna, 2007)</li><li>Decision Procedures: An Algorithmic Point of View (Kroening and Strichman, 2017)</li></ul><p>The corresponding source code, which includes both the simple DPLL solver as well as a full implementation of a Sudoku solver for n by n puzzles (not just 9 by 9!) is available <a href="https://github.com/lucasdu2/sillysat-sudoku" target="_blank" rel="noopener noreferrer">here</a>.
</p><section class="footnotes"><ol><li id="0.5_fnref">Having summer break is one the great perks of being in school.<a href="#0.5_fn">‚Ü©</a></li><li id="1_fnref">lol...to be fair, it's a good movie (maybe a hot take?). And it sort of makes sense in this context.<a href="#1_fn">‚Ü©</a></li><li id="2_fnref">It's pretty funny how many different things a class titled "Programming Languages" can cover. I would usually expect (and probably prefer) a core/required class focused on programming languages to cover "foundational" programming language theory, i.e. things like lambda calculus, type systems and basic results there, semantics, Hoare logic, and so on, but then there's this whole body of material on what could maybe be called <em>implementation theory</em>‚Äîthings related to compiler optimization, static analysis (particularly of programs in existing languages), garbage collection, etc. that are also really interesting and valid directions a course on programming languages can take.<a href="#2_fn">‚Ü©</a></li><li id="3_fnref">Also some math paper-y proofs that rely on some claim of obviousness, i.e. "It is clear that $G'$ is also layered" or "It is easy to see that the algorithm runs in polynomial time." Some of these may indeed be relatively obvious, but I still wish fewer papers would do this and at least sketch the ideas of the proof or give some brief intuition.<a href="#3_fn">‚Ü©</a></li><li id="3.1_fnref">For reference, take any inference rule style presentation of Andersen's algorithm, which should be accessible with a quick web search or LLM query üôÉ<a href="#3.1_fn">‚Ü©</a></li><li id="4_fnref">Since BFS is technically linear time, for example, or more specifically $\mathcal{O}(V+E)$ for some graph $G = (V, E)$. Or an appeal to Wikipedia citations <a href="https://en.wikipedia.org/wiki/Reachability#cite_note-4" target="_blank" rel="noopener noreferrer">here</a>.<a href="#4_fn">‚Ü©</a></li></ol></section><footer>‚ô¶‚ô¶‚ô¶</footer></body>
</html>